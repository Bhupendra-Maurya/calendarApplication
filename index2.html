<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Scrollable Calendar</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f5f5;
        }

        .app {
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            z-index: 100;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        /* Calendar Container */
        .calendar-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-top: 80px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        .calendar-container::-webkit-scrollbar {
            width: 6px;
        }

        .calendar-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .calendar-container::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        /* Month Grid */
        .month-grid {
            padding: 0 1rem 2rem;
            margin-bottom: 1rem;
        }

        .month-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #666;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
        }

        .days-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            margin-bottom: 1px;
        }

        .day-header {
            background: #fff;
            padding: 0.75rem 0.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            color: #666;
            border-radius: 8px 8px 0 0;
        }

        .days-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 0 0 12px 12px;
        }

        /* Day Cell */
        .day-cell {
            background: white;
            min-height: 80px;
            padding: 0.5rem;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: background-color 0.2s ease;
        }

        .day-cell:hover {
            background-color: #f8f9fa;
        }

        .day-cell.other-month {
            background-color: #fafafa;
            color: #ccc;
        }

        .day-number {
            font-size: 0.875rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 0.25rem;
        }

        .day-cell.other-month .day-number {
            color: #ccc;
        }

        .day-cell.today .day-number {
            background: #007AFF;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        /* Journal Entry in Day Cell */
        .journal-entry {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            margin-top: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .journal-entry:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .journal-entry-rating {
            display: flex;
            align-items: center;
            margin-top: 0.125rem;
        }

        .star {
            color: #ffd700;
            font-size: 0.75rem;
            margin-right: 0.125rem;
        }

        /* Journal Modal */
        .journal-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .journal-card {
            background: white;
            border-radius: 16px;
            max-width: 400px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            animation: modalOpen 0.3s ease forwards;
        }

        @keyframes modalOpen {
            to {
                transform: scale(1);
            }
        }

        .journal-image {
            width: 100%;
            height: 250px;
            object-fit: cover;
        }

        .journal-content {
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(90vh - 250px);
        }

        .journal-date {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .journal-rating {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .journal-rating .star {
            color: #ffd700;
            font-size: 1.25rem;
            margin-right: 0.25rem;
        }

        .journal-rating-number {
            margin-left: 0.5rem;
            font-weight: 600;
            color: #666;
        }

        .journal-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .category-tag {
            background: #f0f0f0;
            color: #666;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .journal-description {
            color: #333;
            line-height: 1.6;
            font-size: 0.9375rem;
        }

        /* Navigation Buttons */
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.25rem;
            color: #333;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .modal-nav:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-50%) scale(1.1);
        }

        .modal-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: translateY(-50%) scale(1);
        }

        .modal-nav.prev {
            left: -20px;
        }

        .modal-nav.next {
            right: -20px;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 1.125rem;
            transition: background-color 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .calendar-container {
                padding-top: 70px;
            }
            
            .month-grid {
                padding: 0 0.5rem 1rem;
            }
            
            .day-cell {
                min-height: 60px;
                padding: 0.375rem;
            }
            
            .day-header {
                padding: 0.5rem 0.25rem;
                font-size: 0.75rem;
            }
            
            .journal-modal {
                padding: 0.5rem;
            }
            
            .journal-card {
                max-height: 95vh;
            }
            
            .journal-image {
                height: 200px;
            }
            
            .journal-content {
                padding: 1rem;
                max-height: calc(95vh - 200px);
            }
            
            .modal-nav {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }
            
            .modal-nav.prev {
                left: -18px;
            }
            
            .modal-nav.next {
                right: -18px;
            }
        }

        @media (max-width: 480px) {
            .journal-entry {
                font-size: 0.6875rem;
                padding: 0.1875rem 0.375rem;
            }
            
            .day-cell {
                min-height: 50px;
            }
            
            .star {
                font-size: 0.625rem;
            }
        }

        /* Loading states */
        .loading {
            display: flex;
            justify-content: center;
            padding: 2rem;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    
    <script type="module">
        const { useState, useEffect, useCallback, useRef, StrictMode } = React;
        const { createRoot } = ReactDOM;

        // Date Helper Functions
        const parseDate = (dateString) => {
            const [day, month, year] = dateString.split('/').map(Number);
            return new Date(year, month - 1, day);
        };

        const isSameDay = (date1, date2) => {
            return date1.getFullYear() === date2.getFullYear() &&
                   date1.getMonth() === date2.getMonth() &&
                   date1.getDate() === date2.getDate();
        };

        const getMonthName = (month) => {
            const months = [
                'January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'
            ];
            return months[month];
        };

        const getDaysInMonth = (year, month) => {
            return new Date(year, month + 1, 0).getDate();
        };

        const getFirstDayOfMonth = (year, month) => {
            return new Date(year, month, 1).getDay();
        };

        const getMonthData = (year, month) => {
            const daysInMonth = getDaysInMonth(year, month);
            const firstDayOfWeek = getFirstDayOfMonth(year, month);
            const daysInPrevMonth = getDaysInMonth(year, month - 1);
            
            const days = [];
            
            // Previous month's trailing days
            for (let i = firstDayOfWeek - 1; i >= 0; i--) {
                days.push({
                    day: daysInPrevMonth - i,
                    isCurrentMonth: false,
                    date: new Date(year, month - 1, daysInPrevMonth - i),
                    isPrevMonth: true
                });
            }
            
            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                days.push({
                    day,
                    isCurrentMonth: true,
                    date: new Date(year, month, day),
                    isPrevMonth: false
                });
            }
            
            // Next month's leading days to complete the grid
            const remainingDays = 42 - days.length; // 6 rows × 7 days = 42
            for (let day = 1; day <= remainingDays; day++) {
                days.push({
                    day,
                    isCurrentMonth: false,
                    date: new Date(year, month + 1, day),
                    isPrevMonth: false
                });
            }
            
            return days;
        };

        const getJournalEntriesForDate = (entries, date) => {
            return entries.filter(entry => {
                const entryDate = parseDate(entry.date);
                return isSameDay(entryDate, date);
            });
        };

        // Journal Data
        const getAllJournalEntries = () => [
            {
                imgUrl: "https://images.pexels.com/photos/774909/pexels-photo-774909.jpeg",
                rating: 4.8,
                categories: ["Deep Conditioning", "Moisture", "Hair Growth", "Natural Products"],
                date: "05/08/2025",
                description: "Finally tried the coconut oil deep conditioning treatment. My hair feels incredibly soft and manageable. Noticed significantly less breakage during combing."
            },
            {
                imgUrl: "https://images.pexels.com/photos/33669506/pexels-photo-33669506.jpeg",
                rating: 3.5,
                categories: ["Protein Treatment", "Hair Repair", "Salon Visit"],
                date: "12/08/2025",
                description: "Protein treatment at the salon. Hair feels a bit stiff - might have been too much protein. Need to balance with more moisture next time."
            },
            {
                imgUrl: "https://images.pexels.com/photos/33653029/pexels-photo-33653029.jpeg",
                rating: 4.5,
                categories: ["Protective Style", "Braids", "Scalp Care"],
                date: "20/08/2025",
                description: "Got box braids installed. Used tea tree oil on scalp before installation. Feeling confident about this protective style for the next few weeks."
            },
            {
                imgUrl: "https://images.pexels.com/photos/33659051/pexels-photo-33659051.png",
                rating: 4.2,
                categories: ["Hair Mask", "DIY Treatment", "Hydration"],
                date: "28/08/2025",
                description: "Made a DIY avocado and honey hair mask. Hair feels incredibly nourished. Will definitely repeat this treatment next month."
            },
            {
                imgUrl: "https://images.pexels.com/photos/1130626/pexels-photo-1130626.jpeg",
                rating: 5.0,
                categories: ["New Product", "Leave-in Conditioner", "Curl Definition"],
                date: "03/09/2025",
                description: "Tried the new curl-defining leave-in conditioner. Amazing results! Perfect curl definition without any crunch. Found my holy grail product!"
            },
            {
                imgUrl: "https://images.pexels.com/photos/33699867/pexels-photo-33699867.jpeg",
                rating: 3.8,
                categories: ["Trim", "Hair Health", "Split Ends"],
                date: "10/09/2025",
                description: "Got a much-needed trim today. Removed about an inch of damaged ends. Hair looks healthier but shorter than expected."
            },
            {
                imgUrl: "https://images.pexels.com/photos/33703919/pexels-photo-33703919.jpeg",
                rating: 4.6,
                categories: ["Oil Treatment", "Scalp Massage", "Growth"],
                date: "15/09/2025",
                description: "Weekly scalp massage with rosemary oil blend. Starting to notice new growth at temples. Consistent routine is paying off!"
            },
            {
                imgUrl: "https://images.pexels.com/photos/33681810/pexels-photo-33681810.jpeg",
                rating: 4.0,
                categories: ["Wash Day", "Detangling", "Deep Clean"],
                date: "20/09/2025",
                description: "Thorough wash day with clarifying shampoo. Took time to properly section and detangle. Hair feels clean and refreshed."
            },
            {
                imgUrl: "https://images.pexels.com/photos/33711580/pexels-photo-33711580.jpeg",
                rating: 4.7,
                categories: ["Heatless Styling", "Overnight Routine", "Waves"],
                date: "25/09/2025",
                description: "Tried silk rope braid overnight for heatless waves. Woke up to beautiful, bouncy waves. Love this damage-free styling method!"
            },
            {
                imgUrl: "https://images.pexels.com/photos/33714711/pexels-photo-33714711.jpeg",
                rating: 4.3,
                categories: ["Color Care", "Purple Shampoo", "Toning"],
                date: "30/09/2025",
                description: "Used purple shampoo to tone highlights. Color looks refreshed and brassy tones are gone. Need to remember not to leave it on too long next time."
            }
        ];

        // Custom Hooks
        const useInfiniteScroll = () => {
            const containerRef = useRef(null);
            const [months, setMonths] = useState([]);
            const [currentMonth, setCurrentMonth] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const scrollPositionRef = useRef(0);
            const lastScrollTime = useRef(0);

            // Initialize with current month and surrounding months
            useEffect(() => {
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonthIndex = now.getMonth();
                
                const initialMonths = [];
                
                // Generate 12 months before, current month, and 12 months after
                for (let i = -12; i <= 12; i++) {
                    const date = new Date(currentYear, currentMonthIndex + i, 1);
                    initialMonths.push({
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        id: `${date.getFullYear()}-${date.getMonth()}`
                    });
                }
                
                setMonths(initialMonths);
                setCurrentMonth({
                    year: currentYear,
                    month: currentMonthIndex,
                    id: `${currentYear}-${currentMonthIndex}`
                });
            }, []);

            // Add more months when scrolling near the edges
            const addMonths = useCallback((direction, count = 6) => {
                setMonths(prevMonths => {
                    if (prevMonths.length === 0) return prevMonths;
                    
                    const newMonths = [...prevMonths];
                    
                    if (direction === 'before') {
                        const firstMonth = prevMonths[0];
                        for (let i = 1; i <= count; i++) {
                            const date = new Date(firstMonth.year, firstMonth.month - i, 1);
                            newMonths.unshift({
                                year: date.getFullYear(),
                                month: date.getMonth(),
                                id: `${date.getFullYear()}-${date.getMonth()}`
                            });
                        }
                    } else {
                        const lastMonth = prevMonths[prevMonths.length - 1];
                        for (let i = 1; i <= count; i++) {
                            const date = new Date(lastMonth.year, lastMonth.month + i, 1);
                            newMonths.push({
                                year: date.getFullYear(),
                                month: date.getMonth(),
                                id: `${date.getFullYear()}-${date.getMonth()}`
                            });
                        }
                    }
                    
                    return newMonths;
                });
            }, []);

            // Handle scroll events and update current month
            const handleScroll = useCallback(() => {
                if (!containerRef.current) return;

                const container = containerRef.current;
                const scrollTop = container.scrollTop;
                const now = Date.now();
                
                // Throttle scroll handling
                if (now - lastScrollTime.current < 16) return; // ~60fps
                lastScrollTime.current = now;

                scrollPositionRef.current = scrollTop;

                // Find the most visible month
                const monthElements = container.querySelectorAll('[data-month-id]');
                let maxVisibleArea = 0;
                let mostVisibleMonth = null;

                monthElements.forEach((element) => {
                    const rect = element.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Calculate visible area
                    const visibleTop = Math.max(rect.top, containerRect.top);
                    const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
                    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                    const visibleArea = visibleHeight * rect.width;
                    
                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        const monthId = element.getAttribute('data-month-id');
                        if (monthId) {
                            const [year, month] = monthId.split('-').map(Number);
                            mostVisibleMonth = { year, month, id: monthId };
                        }
                    }
                });

                if (mostVisibleMonth) {
                    setCurrentMonth(prev => {
                        if (!prev || prev.id !== mostVisibleMonth.id) {
                            return mostVisibleMonth;
                        }
                        return prev;
                    });
                }

                // Load more months when near edges
                const containerHeight = container.clientHeight;
                const scrollHeight = container.scrollHeight;
                
                // Load more months at the top
                if (scrollTop < containerHeight * 2 && !isLoading) {
                    setIsLoading(true);
                    setTimeout(() => {
                        addMonths('before');
                        setIsLoading(false);
                    }, 100);
                }
                
                // Load more months at the bottom
                if (scrollTop > scrollHeight - containerHeight * 3 && !isLoading) {
                    setIsLoading(true);
                    setTimeout(() => {
                        addMonths('after');
                        setIsLoading(false);
                    }, 100);
                }
            }, [addMonths, isLoading]);

            // Attach scroll listener
            useEffect(() => {
                const container = containerRef.current;
                if (!container) return;

                container.addEventListener('scroll', handleScroll, { passive: true });
                
                return () => {
                    container.removeEventListener('scroll', handleScroll);
                };
            }, [handleScroll]);

            return {
                containerRef,
                months,
                currentMonth,
                isLoading
            };
        };

        const useCalendar = () => {
            const [journalEntries, setJournalEntries] = useState([]);
            const [selectedEntry, setSelectedEntry] = useState(null);
            const [currentEntryIndex, setCurrentEntryIndex] = useState(0);
            const [isModalOpen, setIsModalOpen] = useState(false);

            // Load journal entries on mount
            useEffect(() => {
                const entries = getAllJournalEntries();
                // Sort entries by date
                entries.sort((a, b) => {
                    const dateA = parseDate(a.date);
                    const dateB = parseDate(b.date);
                    return dateA.getTime() - dateB.getTime();
                });
                setJournalEntries(entries);
            }, []);

            // Open journal entry modal
            const openJournalEntry = useCallback((entry) => {
                const index = journalEntries.findIndex(e => 
                    e.date === entry.date && e.description === entry.description
                );
                setSelectedEntry(entry);
                setCurrentEntryIndex(index);
                setIsModalOpen(true);
            }, [journalEntries]);

            // Close journal entry modal
            const closeJournalEntry = useCallback(() => {
                setSelectedEntry(null);
                setIsModalOpen(false);
            }, []);

            // Navigate to previous entry
            const goToPreviousEntry = useCallback(() => {
                if (currentEntryIndex > 0) {
                    const newIndex = currentEntryIndex - 1;
                    setCurrentEntryIndex(newIndex);
                    setSelectedEntry(journalEntries[newIndex]);
                }
            }, [currentEntryIndex, journalEntries]);

            // Navigate to next entry
            const goToNextEntry = useCallback(() => {
                if (currentEntryIndex < journalEntries.length - 1) {
                    const newIndex = currentEntryIndex + 1;
                    setCurrentEntryIndex(newIndex);
                    setSelectedEntry(journalEntries[newIndex]);
                }
            }, [currentEntryIndex, journalEntries]);

            // Handle keyboard navigation
            useEffect(() => {
                const handleKeyPress = (event) => {
                    if (!isModalOpen) return;

                    switch (event.key) {
                        case 'ArrowLeft':
                            event.preventDefault();
                            goToPreviousEntry();
                            break;
                        case 'ArrowRight':
                            event.preventDefault();
                            goToNextEntry();
                            break;
                        case 'Escape':
                            event.preventDefault();
                            closeJournalEntry();
                            break;
                    }
                };

                document.addEventListener('keydown', handleKeyPress);
                return () => document.removeEventListener('keydown', handleKeyPress);
            }, [isModalOpen, goToPreviousEntry, goToNextEntry, closeJournalEntry]);

            return {
                journalEntries,
                selectedEntry,
                currentEntryIndex,
                isModalOpen,
                openJournalEntry,
                closeJournalEntry,
                goToPreviousEntry,
                goToNextEntry,
                canGoToPrevious: currentEntryIndex > 0,
                canGoToNext: currentEntryIndex < journalEntries.length - 1
            };
        };

        // Components
        const Header = ({ currentMonth }) => {
            if (!currentMonth) {
                return React.createElement('header', { className: 'header' },
                    React.createElement('h1', null, 'Calendar')
                );
            }

            return React.createElement('header', { className: 'header' },
                React.createElement('h1', null, 
                    `${getMonthName(currentMonth.month)} ${currentMonth.year}`
                )
            );
        };

        const DayCell = ({ day, date, isCurrentMonth, isPrevMonth, journalEntries, onEntryClick }) => {
            const isToday = isSameDay(date, new Date());
            const dayEntries = getJournalEntriesForDate(journalEntries, date);
            
            const cellClassName = [
                'day-cell',
                !isCurrentMonth && 'other-month',
                isToday && 'today'
            ].filter(Boolean).join(' ');

            const renderStars = (rating) => {
                const fullStars = Math.floor(rating);
                const hasHalfStar = rating % 1 >= 0.5;
                const stars = [];

                for (let i = 0; i < fullStars; i++) {
                    stars.push('★');
                }
                
                if (hasHalfStar) {
                    stars.push('☆');
                }

                return stars.slice(0, 5); // Max 5 stars
            };

            return React.createElement('div', { className: cellClassName },
                React.createElement('div', { className: 'day-number' }, day),
                ...dayEntries.map((entry, index) => 
                    React.createElement('div', {
                        key: index,
                        className: 'journal-entry',
                        onClick: () => onEntryClick(entry),
                        title: entry.description.substring(0, 100) + '...'
                    },
                        React.createElement('div', null, entry.categories[0] || 'Journal'),
                        React.createElement('div', { className: 'journal-entry-rating' },
                            ...renderStars(entry.rating).map((star, i) =>
                                React.createElement('span', { key: i, className: 'star' }, star)
                            ),
                            React.createElement('span', { 
                                style: { fontSize: '0.6875rem', marginLeft: '0.25rem' } 
                            }, entry.rating)
                        )
                    )
                )
            );
        };

        const Calendar = ({ months, journalEntries, onEntryClick }) => {
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            const renderMonth = (monthInfo) => {
                const monthData = getMonthData(monthInfo.year, monthInfo.month);
                
                return React.createElement('div', {
                    key: monthInfo.id,
                    className: 'month-grid',
                    'data-month-id': monthInfo.id
                },
                    React.createElement('h2', { className: 'month-title' },
                        `${getMonthName(monthInfo.month)} ${monthInfo.year}`
                    ),
                    React.createElement('div', { className: 'days-header' },
                        ...dayHeaders.map(day =>
                            React.createElement('div', { key: day, className: 'day-header' }, day)
                        )
                    ),
                    React.createElement('div', { className: 'days-grid' },
                        ...monthData.map((dayInfo, index) =>
                            React.createElement(DayCell, {
                                key: `${monthInfo.id}-${index}`,
                                day: dayInfo.day,
                                date: dayInfo.date,
                                isCurrentMonth: dayInfo.isCurrentMonth,
                                isPrevMonth: dayInfo.isPrevMonth,
                                journalEntries,
                                onEntryClick
                            })
                        )
                    )
                );
            };

            return React.createElement('div', { className: 'calendar-months' },
                ...months.map(renderMonth)
            );
        };

        const JournalModal = ({ entry, isOpen, onClose, onPrevious, onNext, canGoToPrevious, canGoToNext }) => {
            // Handle touch events for swiping
            useEffect(() => {
                if (!isOpen) return;

                let startX = 0;
                let startY = 0;
                let isScrolling = false;

                const handleTouchStart = (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    isScrolling = false;
                };

                const handleTouchMove = (e) => {
                    if (!startX || !startY) return;

                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const diffX = Math.abs(currentX - startX);
                    const diffY = Math.abs(currentY - startY);

                    // Determine if this is a horizontal swipe
                    if (diffX > diffY && diffX > 30) {
                        if (!isScrolling) {
                            e.preventDefault();
                            isScrolling = true;
                        }
                    }
                };

                const handleTouchEnd = (e) => {
                    if (!startX || !startY) return;

                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const diffX = startX - endX;
                    const diffY = Math.abs(startY - endY);

                    // Only trigger swipe if horizontal movement is greater than vertical
                    if (Math.abs(diffX) > diffY && Math.abs(diffX) > 50) {
                        if (diffX > 0 && canGoToNext) {
                            onNext();
                        } else if (diffX < 0 && canGoToPrevious) {
                            onPrevious();
                        }
                    }

                    startX = 0;
                    startY = 0;
                    isScrolling = false;
                };

                document.addEventListener('touchstart', handleTouchStart, { passive: false });
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);

                return () => {
                    document.removeEventListener('touchstart', handleTouchStart);
                    document.removeEventListener('touchmove', handleTouchMove);
                    document.removeEventListener('touchend', handleTouchEnd);
                };
            }, [isOpen, canGoToPrevious, canGoToNext, onPrevious, onNext]);

            if (!isOpen || !entry) return null;

            const entryDate = parseDate(entry.date);
            const formattedDate = entryDate.toLocaleDateString('en-US', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });

            const renderStars = (rating) => {
                const fullStars = Math.floor(rating);
                const hasHalfStar = rating % 1 >= 0.5;
                const stars = [];

                for (let i = 0; i < 5; i++) {
                    if (i < fullStars) {
                        stars.push('★');
                    } else if (i === fullStars && hasHalfStar) {
                        stars.push('☆');
                    } else {
                        stars.push('☆');
                    }
                }

                return stars;
            };

            return React.createElement('div', { 
                className: 'journal-modal', 
                onClick: onClose 
            },
                React.createElement('div', { 
                    className: 'journal-card', 
                    onClick: (e) => e.stopPropagation() 
                },
                    React.createElement('button', { 
                        className: 'modal-close', 
                        onClick: onClose 
                    }, '×'),
                    
                    React.createElement('button', { 
                        className: 'modal-nav prev',
                        onClick: onPrevious,
                        disabled: !canGoToPrevious,
                        title: 'Previous entry'
                    }, '‹'),
                    
                    React.createElement('button', { 
                        className: 'modal-nav next',
                        onClick: onNext,
                        disabled: !canGoToNext,
                        title: 'Next entry'
                    }, '›'),
                    
                    React.createElement('img', { 
                        src: entry.imgUrl, 
                        alt: 'Journal entry',
                        className: 'journal-image',
                        onError: (e) => {
                            e.currentTarget.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjI1MCIgdmlld0JveD0iMCAwIDQwMCAyNTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iMjUwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0xNzUgMTAwSDE0NVYxMzBIMTc1VjEwMFoiIGZpbGw9IiNEREREREQiLz4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPHA+CjwvcGF0aD4KPC9zdmc+Cg==';
                        }
                    }),
                    
                    React.createElement('div', { className: 'journal-content' },
                        React.createElement('h2', { className: 'journal-date' }, formattedDate),
                        
                        React.createElement('div', { className: 'journal-rating' },
                            ...renderStars(entry.rating).map((star, i) =>
                                React.createElement('span', { key: i, className: 'star' }, star)
                            ),
                            React.createElement('span', { className: 'journal-rating-number' }, entry.rating)
                        ),
                        
                        React.createElement('div', { className: 'journal-categories' },
                            ...entry.categories.map((category, index) =>
                                React.createElement('span', { 
                                    key: index, 
                                    className: 'category-tag' 
                                }, category)
                            )
                        ),
                        
                        React.createElement('p', { className: 'journal-description' }, entry.description)
                    )
                )
            );
        };

        const App = () => {
            const { containerRef, months, currentMonth } = useInfiniteScroll();
            const {
                journalEntries,
                selectedEntry,
                isModalOpen,
                openJournalEntry,
                closeJournalEntry,
                goToPreviousEntry,
                goToNextEntry,
                canGoToPrevious,
                canGoToNext
            } = useCalendar();

            return React.createElement('div', { className: 'app' },
                React.createElement(Header, { currentMonth }),
                
                React.createElement('div', { 
                    ref: containerRef, 
                    className: 'calendar-container' 
                },
                    React.createElement(Calendar, {
                        months,
                        journalEntries,
                        onEntryClick: openJournalEntry
                    })
                ),

                React.createElement(JournalModal, {
                    entry: selectedEntry,
                    isOpen: isModalOpen,
                    onClose: closeJournalEntry,
                    onPrevious: goToPreviousEntry,
                    onNext: goToNextEntry,
                    canGoToPrevious,
                    canGoToNext
                })
            );
        };

        // Render the app
        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(StrictMode, null, React.createElement(App)));
    </script>
</body>
</html>